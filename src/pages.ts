import { addTemplate, updateTemplates } from '@nuxt/kit'
import { readFileSync } from 'node:fs'
import { isString } from '@intlify/shared'
import { parse as parseSFC } from '@vue/compiler-sfc'
import { parseAndWalk } from 'oxc-walker'
import { mkdir, readFile, writeFile } from 'node:fs/promises'
import { parseSegment, toVueRouterSegment } from 'unrouting'
import { localizeRoutes } from './routing'
import { dirname, parse as parsePath, resolve } from 'pathe'
import { createRoutesContext } from 'unplugin-vue-router'
import { resolveOptions } from 'unplugin-vue-router/options'
import { transform } from './transform/resource'

import type { Nuxt, NuxtPage, ResolvedNuxtTemplate } from '@nuxt/schema'
import type { EditableTreeNode, Options as TypedRouterOptions } from 'unplugin-vue-router'
import type { NuxtI18nOptions } from './types'
import type { I18nNuxtContext } from './context'
import type { ComputedRouteOptions, RouteOptionsResolver } from './kit/gen'
import type { I18nRoute } from './runtime/composables'
import { type CallExpression, type ExpressionStatement, type ObjectExpression, parseSync } from 'oxc-parser'

export class NuxtPageAnalyzeContext {
  config: NuxtI18nOptions['pages']
  pages: Map<string, { path: string, name?: string }> = new Map()
  pathToConfig: Record<string, Record<string, string | boolean> | undefined> = {}
  fileToPath: Record<string, string> = {}

  constructor(config: NuxtI18nOptions['pages']) {
    this.config = config || {}
  }

  addPage(page: NuxtPage, path: string, name?: string) {
    this.pages.set(page.file!, { path, name })
    const p = path === 'index' ? '/' : '/' + path.replace(/\/index$/, '')
    this.fileToPath[page.file!] = p
  }
}

type NarrowedNuxtPage = Omit<NuxtPage, 'redirect' | 'children'> & {
  redirect?: (Omit<NarrowedNuxtPage, 'name'> & { name?: string }) | string
  children?: NarrowedNuxtPage[]
}

export async function setupPages({ localeCodes, options, normalizedLocales }: I18nNuxtContext, nuxt: Nuxt) {
  const routeResources = {
    i18nPathToPath: {},
    pathToI18nConfig: {},
  }

  addTemplate({
    filename: 'i18n-route-resources.mjs',
    write: true,
    getContents: () => {
      return `// Generated by @nuxtjs/i18n
export const pathToI18nConfig = ${JSON.stringify(routeResources.pathToI18nConfig, null, 2)};
export const i18nPathToPath = ${JSON.stringify(routeResources.i18nPathToPath, null, 2)};`
    },
  })
  if (!localeCodes.length) { return }

  let includeUnprefixedFallback = !nuxt.options.ssr
  nuxt.hook('nitro:init', () => {
    includeUnprefixedFallback = options.strategy !== 'prefix'
  })

  const projectLayer = nuxt.options._layers[0]
  const typedRouter = await setupExperimentalTypedRoutes(options, nuxt)

  nuxt.options.experimental.extraPageMetaExtractionKeys ??= []
  nuxt.options.experimental.extraPageMetaExtractionKeys.push('i18n')
  nuxt.hook(
    nuxt.options.experimental.scanPageMeta === 'after-resolve' ? 'pages:resolved' : 'pages:extend',
    async (pages) => {
      const ctx = new NuxtPageAnalyzeContext(options.pages)

      // analyze layer pages
      for (const layer of nuxt.options._layers) {
        const pagesDir = resolve(projectLayer!.config.rootDir, layer.config.srcDir, layer.config.dir?.pages ?? 'pages')
        analyzeNuxtPages(ctx, pagesDir, pages)
      }

      if (typedRouter) {
        await typedRouter.createContext(pages).scanPages(false)
      }

      const localizedPages = localizeRoutes(pages as NarrowedNuxtPage[], {
        ...options,
        includeUnprefixedFallback,
        locales: normalizedLocales,
        optionsResolver: getRouteOptionsResolver(ctx, options.defaultLocale, options.customRoutes),
      })

      // keep root when using prefixed routing without prerendering
      const indexPage = pages.find(x => x.path === '/')
      if (options.strategy === 'prefix' && indexPage != null) {
        localizedPages.unshift(indexPage as NarrowedNuxtPage)
      }

      const invertedMap = {} as Record<string, Record<string, string | false>>
      const localizedMapInvert: Record<string, string> = {}
      for (const [path, localeConfig] of Object.entries(ctx.pathToConfig)) {
        const resPath = resolveRoutePath(path)
        invertedMap[resPath] ??= {}
        for (const [locale, localePath] of Object.entries(localeConfig!)) {
          const localized = localePath === true ? path : localePath
          invertedMap[resPath][locale] = localized && resolveRoutePath(localized)
          if (invertedMap[resPath][locale]) {
            localizedMapInvert[invertedMap[resPath][locale]] = resPath
          }
        }
      }
      routeResources.i18nPathToPath = localizedMapInvert
      routeResources.pathToI18nConfig = invertedMap

      await updateTemplates({
        filter: (template: ResolvedNuxtTemplate) => template.filename === 'i18n-route-resources.mjs',
      })

      // do not mutate pages if localization is skipped
      if (pages !== localizedPages) {
        pages.length = 0
        pages.unshift(...localizedPages)
      }
    },
  )
}

/**
 * Expression to to find the `RouteNamedMap` generated by uvr, used to replace with `RouteNamedMapI18n`
 */
const routeNamedMapTypeRE = /RouteNamedMap\b/

/**
 * Declaration file containing the generated route types
 */
const declarationFile = './types/typed-router-i18n.d.ts'

/**
 * Setup experiment typed routes feature if enabled
 */
async function setupExperimentalTypedRoutes(userOptions: NuxtI18nOptions, nuxt: Nuxt) {
  if (!nuxt.options.experimental.typedPages || userOptions.experimental?.typedPages === false) {
    return undefined
  }

  const dtsFile = resolve(nuxt.options.buildDir, declarationFile)

  /**
   * Typed route generation from Nuxt with modifications
   * https://github.com/nuxt/nuxt/blob/781d8c4174c410a7aff6b809817b15eae85d3ba8/packages/nuxt/src/pages/module.ts#L160-L208
   */
  function createContext(pages: NuxtPage[]) {
    const typedRouteroptions: TypedRouterOptions = {
      routesFolder: [],
      dts: dtsFile,
      logs: !!nuxt.options.debug,
      watch: false,

      beforeWriteFiles(rootPage) {
        rootPage.children.forEach(child => child.delete())
        function addPage(parent: EditableTreeNode, page: NuxtPage) {
          // @ts-expect-error TODO: either fix types upstream or figure out another
          // way to add a route without a file, which must be possible
          const route = parent.insert(page.path, page.file)
          if (page.meta) {
            route.addToMeta(page.meta)
          }
          if (page.alias) {
            route.addAlias(page.alias)
          }
          if (page.name) {
            route.name = page.name
          }
          // TODO: implement redirect support
          // if (page.redirect) {}
          if (page.children) {
            page.children.forEach(child => addPage(route, child))
          }
        }

        for (const page of pages) {
          addPage(rootPage, page)
        }
      },
    }

    const context = createRoutesContext(resolveOptions(typedRouteroptions))

    /**
     * Wrap `scanPages` to rename interface `RouteNamedMap` => `RouteNamedMapI18n`
     */
    const originalScanPages = context.scanPages.bind(context)
    context.scanPages = async function (watchers = false) {
      await mkdir(dirname(dtsFile), { recursive: true })
      await originalScanPages(watchers)

      const dtsContent = await readFile(dtsFile, 'utf-8')

      if (routeNamedMapTypeRE.test(dtsContent)) {
        await writeFile(dtsFile, dtsContent.replace(routeNamedMapTypeRE, 'RouteNamedMapI18n'))
      }
    }

    return context
  }

  addTemplate({
    filename: resolve(nuxt.options.buildDir, './types/i18n-generated-route-types.d.ts'),
    getContents: () => {
      return `// Generated by @nuxtjs/i18n
declare module 'vue-router' {
  import type { RouteNamedMapI18n } from 'vue-router/auto-routes'

  export interface TypesConfig {
    RouteNamedMapI18n: RouteNamedMapI18n
  }
}

export {}`
    },
  })

  nuxt.hook('prepare:types', ({ references }) => {
    // This file will be generated by unplugin-vue-router
    references.push({ path: declarationFile })
    references.push({ types: './types/i18n-generated-route-types.d.ts' })
  })

  await createContext(nuxt.apps.default?.pages ?? []).scanPages(false)

  return { createContext }
}

/**
 * Analyze page path
 */
function analyzePagePath(pagePath: string, parents = 0) {
  const { dir, name } = parsePath(pagePath)

  if (parents > 0 || dir !== '/') {
    return `${dir.slice(1, dir.length)}/${name}`
  }

  return name
}

/**
 * Construct the map of full paths from NuxtPage to support custom routes.
 * `NuxtPage` of the nested route doesn't have a slash (`/`) and isnâ€™t the full path.
 */
export function analyzeNuxtPages(ctx: NuxtPageAnalyzeContext, pagesDir: string, pages?: NuxtPage[]): void {
  if (pages == null || pages.length === 0) { return }

  for (const page of pages) {
    if (page.file == null) { continue }

    const [, filePath] = page.file.split(pagesDir)
    if (filePath == null) { continue }

    // if route has an index child the parent will not have a name
    ctx.addPage(page, analyzePagePath(filePath), page.name ?? page.children?.find(x => x.path.endsWith('/index'))?.name)

    analyzeNuxtPages(ctx, pagesDir, page.children)
  }
}

/**
 * Function factory, returns a function based on the `customRoutes` option property
 */
export function getRouteOptionsResolver(
  ctx: NuxtPageAnalyzeContext,
  defaultLocale: string,
  customRoutes: NuxtI18nOptions['customRoutes'],
): RouteOptionsResolver {
  return (route, localeCodes) => {
    const res = getRouteOptions(route, localeCodes, ctx, defaultLocale, customRoutes)
    if (route.file) {
      const localeCfg = res?.srcPaths
      const mappedPath = ctx.fileToPath[route.file]!
      ctx.pathToConfig[mappedPath] ??= {} as Record<string, string | boolean>

      // set paths for all locales, assume no custom path is a disabled locale
      for (const l of localeCodes) {
        ctx.pathToConfig[mappedPath][l] ??= localeCfg?.[l] ?? false
      }

      for (const l of res?.locales ?? []) {
        ctx.pathToConfig[mappedPath][l] ||= true
      }
    }

    return res
  }
}

function resolveRoutePath(path: string): string {
  const tokens = parseSegment(path.slice(1))
  return '/' + toVueRouterSegment(tokens)
}

function getRouteFromConfig(
  ctx: NuxtPageAnalyzeContext,
  route: NuxtPage,
  localeCodes: string[],
): ComputedRouteOptions | false | undefined {
  const pageMeta = ctx.pages.get(route.file!)

  if (pageMeta == null) {
    return undefined
  }

  const valueByName = pageMeta?.name ? ctx.config?.[pageMeta.name] : undefined
  const valueByPath = pageMeta?.path != null ? ctx.config?.[pageMeta.path] : undefined
  const resolved = valueByName ?? valueByPath
  if (!resolved) { return resolved }
  return {
    paths: (resolved ?? {}) as Record<string, string>,
    locales: localeCodes.filter(locale => resolved[locale] !== false),
  }
}

function getRouteFromResource(
  localeCodes: string[],
  resolved: ComputedRouteOptions | I18nRoute | false | undefined,
): ComputedRouteOptions | false | undefined {
  if (!resolved) { return resolved }
  return {
    paths: (resolved.paths ?? {}) as Record<string, string>,
    locales: resolved?.locales || localeCodes,
  }
}

function getRouteOptions(
  route: NuxtPage,
  localeCodes: string[],
  ctx: NuxtPageAnalyzeContext,
  defaultLocale: string,
  mode: 'config' | 'page' | 'meta' = 'config',
) {
  let resolvedOptions
  if (mode === 'config') {
    resolvedOptions = getRouteFromConfig(ctx, route, localeCodes)
  } else {
    resolvedOptions = getRouteFromResource(
      localeCodes,
      mode === 'page' ? getI18nRouteConfig(route.file!) : (route.meta?.i18n as I18nRoute | false | undefined),
    )
  }

  // routing disabled
  if (resolvedOptions === false) {
    return undefined
  }

  const locales = resolvedOptions?.locales || localeCodes
  const paths: Record<string, string> = {}

  // skip if no page options defined
  if (!resolvedOptions) {
    return { locales, paths }
  }

  // construct paths object
  for (const locale of resolvedOptions.locales) {
    // set custom path if any
    if (isString(resolvedOptions.paths[locale])) {
      paths[locale] = resolveRoutePath(resolvedOptions.paths[locale])
      continue
    }

    // set default locale's custom path if any
    if (isString(resolvedOptions.paths[defaultLocale])) {
      paths[locale] = resolveRoutePath(resolvedOptions.paths[defaultLocale])
    }
  }

  return { locales, paths, srcPaths: resolvedOptions.paths }
}

/**
 * Parse page component at `absolutePath` and extract argument passed to `defineI18nRoute()`
 */
function getI18nRouteConfig(absolutePath: string, vfs: Record<string, string> = {}) {
  let extract: false | ComputedRouteOptions | undefined = undefined

  try {
    const content = absolutePath in vfs ? vfs[absolutePath]! : readFileSync(absolutePath, 'utf-8')
    if (!content.includes('defineI18nRoute')) { return undefined }

    const { descriptor } = parseSFC(content)

    const script = descriptor.scriptSetup || descriptor.script
    if (!script) { return undefined }

    const lang = typeof script.attrs.lang === 'string' && /j|tsx/.test(script.attrs.lang) ? 'tsx' : 'ts'
    let code = script.content

    parseAndWalk(script.content, absolutePath.replace(/\.\w+$/, '.' + lang), (node) => {
      if (extract != null) { return }

      if (
        node.type !== 'CallExpression'
        || node.callee.type !== 'Identifier'
        || node.callee.name !== 'defineI18nRoute'
      ) { return }

      let routeArgument = node.arguments[0]
      if (routeArgument == null) { return }

      if (typeof script.attrs.lang === 'string' && /tsx?/.test(script.attrs.lang)) {
        const transformed = transform('', script.content.slice(node.start, node.end).trim(), { lang })
        code = transformed.code

        if (transformed.errors.length) {
          for (const error of transformed.errors) {
            console.warn(`Error while transforming \`defineI18nRoute()\`` + error.codeframe)
          }
          return
        }

        // we already know that the first statement is a call expression
        routeArgument = (
          (parseSync('', transformed.code, { lang: 'js' }).program.body[0]! as ExpressionStatement)
            .expression as CallExpression
        ).arguments[0]! as ObjectExpression
      }

      extract = evalAndValidateValue(code.slice(routeArgument.start, routeArgument.end).trim())
    })
  } catch (e: unknown) {
    console.warn(`[nuxt-i18n] Couldn't read component data at ${absolutePath}: (${(e as Error).message})`)
  }

  return extract satisfies false | ComputedRouteOptions | undefined
}

function evalValue(value: string) {
  try {
    return new Function(`return (${value})`)() as ComputedRouteOptions | false
  } catch {
    console.error(`[nuxt-i18n] Cannot evaluate value: ${value}`)
    return
  }
}

function evalAndValidateValue(value: string) {
  const evaluated = evalValue(value)
  if (evaluated == null) { return }

  // valid boolean value
  if (typeof evaluated === 'boolean' && evaluated === false) {
    return evaluated
  }

  // valid object
  if (Object.prototype.toString.call(evaluated) === '[object Object]') {
    if (evaluated.locales) {
      if (!Array.isArray(evaluated.locales) || evaluated.locales.some(locale => typeof locale !== 'string')) {
        console.warn(`[nuxt-i18n] Invalid locale option used with \`defineI18nRoute\`: ${value}`)
        return
      }
    }
    if (evaluated.paths && Object.prototype.toString.call(evaluated.paths) !== '[object Object]') {
      console.warn(`[nuxt-i18n] Invalid paths option used with \`defineI18nRoute\`: ${value}`)
      return
    }

    return evaluated
  }

  console.warn(`[nuxt-i18n] Invalid value passed to \`defineI18nRoute\`: ${value}`)
}
